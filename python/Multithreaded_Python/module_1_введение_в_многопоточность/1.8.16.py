# Ваша задача - координировать ряд киберопераций, каждая из которых имеет уникальную цель и кодовое имя. Вы должны управлять командой агентов (представленных потоками), где каждый агент назначен на выполнение конкретной миссии. Ваша роль - инициировать, мониторить и подтверждать успешное завершение каждой миссии.
#
# Шаги выполнения задачи:
#
# Вы начнете с организации миссий, где каждая миссия связана с определенным действием. Эти действия будут выполнены в отдельных потоках. Ключ в словаре missions - это имя потока, а значение - задание миссии.
#
# # Словарь имен потоков и их миссий
# # Полный словарь вшит в задачу
#
# missions = {
#     "Thread-Scan": "Сканирование данных",
#     "Thread-Hack": "Взлом системы",
# ...,
# }
# Для каждой миссии создайте поток, используя функцию mission в качестве целевой задачи потока. Каждому потоку будет передано его уникальное задание. Важно контролировать и отображать статус миссии на каждом этапе ее выполнения:
#
# Начало выполнения миссии
#
# [Сканирование данных] Миссия началась.
#
# print(f"[{mission_name}] Миссия началась.")
#
#
# После завершения выполнения миссии
#
# [Сканирование данных] Миссия успешно выполнена!
#
# print(f"[{mission_name}] Миссия успешно выполнена!")
#
#
# Статус миссии до запуска потока
#
# [Thread-Scan (Сканирование данных)] Статус миссии до запуска: False
#
# print(f"[{thread_name} ({mission_name})] Статус миссии до запуска: {thread.is_alive()}")
#
#
# Статус миссии после запуска потока
#
# [Thread-Scan (Сканирование данных)] Миссия активна: True
#
# print(f"[{thread_name} ({mission_name})] Миссия активна: {thread.is_alive()}")
#
#
# Статус миссии после завершения работы потока
#
# [Thread-Scan (Сканирование данных)] Статус миссии после завершения: True
#
# print(f"[{thread.name} ({missions[thread.name]})] Статус миссии после завершения: {not thread.is_alive()}")
#
#
# Следите за ходом выполнения каждой миссии. Вам необходимо убедиться, что все миссии успешно завершились.
#
# Технические детали:
#
# Функция mission должна выводить сообщения о начале и успешном завершении миссии. Используйте time.sleep(random.randint(1, 3)) для имитации продолжительности выполнения миссии.
# Перед запуском, во время выполнения и после завершения миссии выводите соответствующие уведомления, используя информацию из словаря missions и методы потока для проверки его статуса.

import threading
import time

missions = {
    "Thread-Scan": "Сканирование данных",
    "Thread-Hack": "Взлом системы",
    "Thread-Decrypt": "Дешифровка сообщений",
    "Thread-Backup": "Резервное копирование",
    "Thread-Inject": "Внедрение кода",
    "Thread-Exploit": "Эксплуатация уязвимости",
    "Thread-Clean": "Очистка следов",
    "Thread-Exfil": "Экфильтрация данных",
    "Thread-Spoof": "Подмена идентификатора",
    "Thread-DDOS": "Атака на отказ в обслуживании",
}


def mission(mission_name: str) -> None:
    print(f"[{mission_name}] Миссия началась.")

    time.sleep(1)

    print(f"[{mission_name}] Миссия успешно выполнена!")


def main():
    threads = []

    for thread_name, mission_name in missions.items():

        thread = threading.Thread(
            target=mission, args=(mission_name,), name=thread_name
        )

        print(
            f"[{thread.name} ({mission_name})] Статус миссии до запуска: {thread.is_alive()}"
        )

        thread.start()
        threads.append(thread)

        print(f"[{thread.name} ({mission_name})] Миссия активна: {thread.is_alive()}")

    for thread in threads:
        thread.join()
        print(
            f"[{thread.name} ({missions[thread.name]})] Статус миссии после завершения: {not thread.is_alive()}"
        )


main()
