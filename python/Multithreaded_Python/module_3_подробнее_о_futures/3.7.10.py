# Описание задачи:
#
# Напишите код для обработки заказов в ресторане. Код должен анализировать баланс клиента и стоимость блюда, которое он заказал, и параллельно управлять исключениями, связанными с недостаточностью средств.
#
# Обработка элементов в списке через потоки:
# Имеется список словарей orders, где каждый словарь содержит данные о заказе пользователя, включая его имя, баланс, название и стоимость блюда.
# # Полный список вшит в задачу, вставлять его в поле ответа не нужно
#
# orders = [{'name': 'Ivan', 'balance': 500, 'order': 'борщ', 'Стоимость блюда': 200},
#      {'name': 'User5f4a', 'balance': 117, 'order': 'суп', 'Стоимость блюда': 161},
#      {'name': 'User71e3', 'balance': 749, 'order': 'борщ', 'Стоимость блюда': 213},
#      {'name': 'Userecf7', 'balance': 1509, 'order': 'салат', 'Стоимость блюда': 103},
#      ...
#      ...
#      ...
#      {'name': 'Usera299', 'balance': 45, 'order': 'шашлык', 'Стоимость блюда': 106},
#      {'name': 'Userf4f8', 'balance': 172, 'order': 'шашлык', 'Стоимость блюда': 121},
#      {'name': 'Userc6fd', 'balance': 71, 'order': 'борщ', 'Стоимость блюда': 51}]
# Используйте ThreadPoolExecutor для создания и управления потоками, которые будут обрабатывать заказы из списка orders параллельно.
# Функция process_order():
# Вход: Функция принимает один аргумент order, который является словарем, содержащим информацию о заказе одного пользователя.
# Например:
# {'name': 'Ivan', 'balance': 500, 'order': 'борщ', 'Стоимость блюда': 200},
# Обработка баланса: Функция сначала проверяет, достаточно ли средств на балансе пользователя для оплаты блюда. Если средств недостаточно, функция генерирует исключение ValueError с описанием проблемы.
# raise ValueError(f"Недостаточно средств для заказа {order['order']} пользователя {order['name']}")
# Успешная обработка: Если баланс пользователя достаточен для оплаты блюда, функция возвращает сообщение о том, что заказ успешно обработан.
# return f"Заказ {order['order']} пользователя {order['name']} успешно обработан"
# Обработка исключений:
# Используйте блок try/except для обработки возможных исключений.
# Если во время выполнения функции возникает исключение, оно перехватывается и возвращается вместо обычного результата.
# Вывод программы:
# Для каждого заказа выводите результат его обработки. Результатом может быть либо сообщение об успешной обработке заказа, либо информация об ошибке, если средств недостаточно.
# В консоль должны выводиться сообщения типа: "Заказ [блюдо] пользователя [имя] успешно обработан" или "Недостаточно средств для заказа [блюдо] пользователя [имя]"
# Заказ суп пользователя User22d3 успешно обработан
#
# # или
#
# Недостаточно средств для заказа шашлык пользователя User3cfb


from concurrent.futures import ThreadPoolExecutor
import threading
import time

orders = [
    {"name": "Ivan", "balance": 500, "order": "борщ", "Стоимость блюда": 200},
    {"name": "User5f4a", "balance": 117, "order": "суп", "Стоимость блюда": 161},
    {"name": "User71e3", "balance": 749, "order": "борщ", "Стоимость блюда": 213},
    {"name": "Userecf7", "balance": 1509, "order": "салат", "Стоимость блюда": 103},
    {"name": "Usera299", "balance": 45, "order": "шашлык", "Стоимость блюда": 106},
    {"name": "Userf4f8", "balance": 172, "order": "шашлык", "Стоимость блюда": 121},
    {"name": "Userc6fd", "balance": 71, "order": "борщ", "Стоимость блюда": 51},
]


class OrderProcessing:
    def __init__(self, orders: list):
        self.orders = orders
        self.executor = ThreadPoolExecutor(max_workers=5)

    @staticmethod
    def process_order(order: dict):
        name = order.get("name")
        balance = order.get("balance")
        order_name = order.get("order")
        cost = order.get("Стоимость блюда")

        if balance < cost:
            raise ValueError(
                f"Недостаточно средств для заказа {order_name} пользователя {name}"
            )
        else:
            return f"Заказ {order_name} пользователя {name} успешно обработан"

    def run(self):
        with self.executor as executor:
            for order in self.orders:
                future = executor.submit(self.process_order, order)
                try:
                    result = future.result()
                    print(result)
                except Exception as e:
                    print(e)


op = OrderProcessing(orders)
op.run()
