# Цель задачи:
#
# Написать многопоточный код для обработки большого количества файлов. Каждый файл содержит 1000 числовых строк. Всего файлов 20,000. Задача каждого потока - обработать один файл, вычислить сумму преобразованных чисел и записать результат в новый файл. Итоговый файл должен содержать 20,000 строк, каждая из которых представляет сумму чисел в соответствующем файле по формуле (number * 3) / 4.
#
# Необходимые ссылки:
#
# Валидатор
# Набор файлов
# process_file(filename) функция принимает имя файла и обрабатывает его содержимое. Она читает каждую строку в файле, преобразует строку в число, выполняет арифметические операции (умножение на 3 и деление на 4) и суммирует результат. Полученную сумму необходимо записать в итоговый файл, используя объект блокировки, созданный в main().
#
# import os
# from concurrent.futures import ThreadPoolExecutor
# from threading import Lock
#
# def process_file(filename):
#     """Функция для обработки одного файла."""
#     sum_ = 0
#     with open(filename, 'r') as file:
#         for line in file:
#             # Преобразуем строку в число, умножаем на 3, делим на 4 и суммируем
#             number = int(line.strip())
#             sum_ += (number * 3) / 4
#
#     # Записываем полученную сумму в итоговый файл
#     ...
#
#
# # Допишите функцию main()
# def main():
#     ...
#
#
#
# main()
# main(): Главная функция, должна создать пул потоков и использовать его для обработки всех файлов в заданной директории. Так же в main() должен быть создан объект блокировки. Он должен быть использован для синхронизации записи в итоговый файл для обеспечения целостности данных.
#
# Пошаговый план выполнения задачи:
#
# Скачайте и распакуйте архив с файлами.
# Используйте ThreadPoolExecutor для создания пула потоков. Рекомендуемое количество потоков - 10, но его можно настроить в зависимости от мощности вашего компьютера.
# Для каждого файла в директории создайте отдельный поток и используйте process_file() для его обработки.
# Используйте объект Lock для синхронизации доступа к итоговому файлу. Это необходимо для предотвращения одновременной записи в файл разными потоками, что потенциально может привести к потере данных или их повреждению.
# По мере обработки данных записывайте результаты работы из потоков в итоговый файл. Каждый результат должен быть записан в новую строку файла. Формат строки: сумма чисел в файле с округлением до двух знаков после запятой.
# 3790968.75
# 3732768.0
# 3693681.75
# 3686687.25
# 3908487.0
# 3815848.5
# 3772612.5
# 3781606.5
# 3854164.5
# ...
# После завершения обработки всех файлов у вас должен получиться итоговый файл с 20,000 строками. Используйте предоставленный валидатор для проверки правильности результата.

from concurrent.futures import ThreadPoolExecutor, wait
import os
import threading


class FileProcessor:
    def __init__(self):
        self.lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=10)
        self.result = []
        self.directory = os.path.join(os.path.dirname(__file__), "data2")

    def process_file(self, filename):
        with self.lock:
            sum_ = 0
            with open(f"{self.directory}/{filename}", "r", encoding="utf-8") as file:
                for line in file:
                    number = int(line.strip())
                    sum_ += (number * 3) / 4

            self.result.append(sum_)

    def run_threads(self):
        with self.executor as executor:
            futures = [
                executor.submit(self.process_file, filename)
                for filename in os.listdir(self.directory)
                if filename.endswith(".txt")
            ]

    def write_result(self):
        self.run_threads()

        with self.lock:
            with open("result.txt", "w", encoding="utf-8") as file:
                for sum_ in self.result:
                    file.write(f"{sum_:.2f}\n")


processor = FileProcessor()
processor.write_result()
