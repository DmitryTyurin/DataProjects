# Ваша миссия - управлять кулинарным процессом в ресторане, где работает команда из девяти поваров. У каждого повара есть свой список блюд для приготовления, но в их распоряжении всего пять духовок. Ваша задача - обеспечить эффективное использование духовок, позволяя каждому повару готовить свои блюда в строгом порядке, используя систему блокировок для контроля доступа к духовкам.
#
# # Список блюд и время их приготовления
# # Полный словарь вшит в задачу
#
# dishes = {
#      'Алексей': {'Маргарита': 3, 'Лазанья': 5, 'Креветочная': 4, 'Мидии в сливках': 4, 'Сицилийская': 5},
#      'Марина': {'Мексиканская': 3, 'Вегетарианская': 4},
#      ...
#      ...,
# }
# Шаги выполнения задачи:
#
# Изучите словарь с блюдами и время их приготовления для каждого повара. Учтите, что одновременно в работе может быть не более пяти духовок.
#
# Создайте пять Lock-объектов, соответствующих пяти духовкам. Эти блокировки будут использоваться для синхронизации доступа поваров к духовкам.
#
# Напишите функцию, которая позволяет повару "захватить" свободную духовку с помощью блокировки, приготовить блюдо, а затем "освободить" духовку для использования другими. При этом важно логировать каждый этап приготовления блюда.
#
# Алексей начал(а) готовить Маргарита, время приготовления 3 сек.
# print(f'{chief} начал(а) готовить {dish}, время приготовления {time_to_cook} сек.')
# И
#
# Алексей закончил(а) готовить Маргарита, заняло 3 сек.
# print(f'{chief} закончил(а) готовить {dish}, заняло {time_to_cook} сек.')
# Используйте потоки для имитации работы каждого повара. Повара начинают готовить блюда одновременно, но использование духовок должно регулироваться блокировками.
#
# Вывод вашего кода должен быть примерно следующим.

from concurrent.futures import ThreadPoolExecutor
import threading
import time

dishes = {
    "Алексей": {
        "Маргарита": 3,
        "Лазанья": 5,
        "Креветочная": 4,
        "Мидии в сливках": 4,
        "Сицилийская": 5,
    },
    "Марина": {"Мексиканская": 3, "Вегетарианская": 4},
    "Сергей": {"Свинина по-корейски": 5, "Баранина": 4, "Карбонара": 3},
    "Ирина": {"Харчо": 3, "Болоньезе": 5, "Французская": 4},
    "Николай": {"Том Ям": 5, "Пад Тай": 4, "Фо Бо": 3},
    "Ольга": {"Цезарь": 3, "Греческий": 4, "Оливье": 5},
    "Дмитрий": {"Борщ": 4, "Солянка": 5, "Щи": 3},
    "Елена": {"Ризотто": 5, "Паэлья": 4, "Гаспачо": 3},
    "Михаил": {"Пельмени": 3, "Вареники": 4, "Хинкали": 5},
}


class CookingBattle:
    def __init__(self, dishes: dict):
        self.dishes = dishes
        self.executor = ThreadPoolExecutor(max_workers=10)
        self.semaphore = threading.Semaphore(5)

    def chief_work(self, chief, menu):
        with self.semaphore:
            for dish, time_to_cook in menu.items():
                print(
                    f"{chief} начал(а) готовить {dish}, время приготовления {time_to_cook} сек."
                )

                time.sleep(time_to_cook)

                print(
                    f"{chief} закончил(а) готовить {dish}, заняло {time_to_cook} сек."
                )

    def run_cook(self):
        with self.executor as executor:
            futures = [
                executor.submit(self.chief_work, chief, menu)
                for chief, menu in self.dishes.items()
            ]


battle = CookingBattle(dishes)
battle.run_cook()
