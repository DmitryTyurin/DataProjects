# Проверка чисел на простоту с использованием apply()
# Вам необходимо написать функцию is_prime(n), которая определяет, является ли число n *простым. Для списка чисел используйте пул потоков, чтобы параллельно проверить каждое число на простоту, применив метод apply(). Используйте кортежи для передачи аргументов в функцию is_prime.
#
# *Число считается простым, если оно больше 1 и не имеет положительных делителей, кроме 1 и самого себя. Другими словами, простое число делится без остатка только на 1 и на само себя.
# Вот возможные шаги для определения, является ли число простым:
#
# Проверить число, что оно больше единицы.
# Определить интервал делителей. Это должны быть целые числа в диапазоне от 2 до корня квадратного из исследуемого числа (самый большой возможный делитель в диапазоне) + 1(помним про правую границу диапазона).
# Используя оператор получения остатка от деления % проверить исследуемое число на то, что ни один делитель из диапазона не делит число без остатка.
#
#
# Подход к решению:
#
# Определение функции is_prime(n):
# Создайте функцию is_prime(n), которая принимает одно число n и возвращает True, если число простое, и False в противном случае.
#
# Создание пула потоков:
# Используйте ThreadPool из модуля multiprocessing.pool для создания пула потоков. Размер пула (например, 4 потока) определяет, сколько задач может быть выполнено одновременно.
#
# pool = ThreadPool(4)
# Параллельная проверка чисел на простоту:
# Итерируйте список чисел, используя метод apply() для параллельной проверки каждого числа на простоту. Метод apply() должен вызываться для каждого числа в списке, где первым аргументом является функция is_prime, а вторым — кортеж с проверяемым числом.
#
# Ожидание завершения всех задач:
# После проверки всех чисел закройте пул потоков с помощью метода close(), а затем вызовите join(), чтобы дождаться завершения всех потоков перед продолжением выполнения основной программы.
#
#
#
# Преимущества использования pool.apply() в этой задаче:
#
# pool.apply() позволяет получить результаты в том порядке, в котором были отправлены задачи, что облегчает анализ и интерпретацию данных.
# pool.apply() гарантирует, что результат каждой проверки будет получен до перехода к следующему числу, что может быть критично для зависимых задач.

from multiprocessing.pool import ThreadPool
import math

numbers = [6, 1, 8, 11, 4, 7, 5, 2, 3, 9]


class PrimeNumbers:
    def __init__(self, numbers: list):
        self.numbers = numbers
        self.pool = ThreadPool(4)
        self.results = []

    @staticmethod
    def is_prime(n):
        if n <= 1:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        max_divisor = math.isqrt(n) + 1
        for d in range(3, max_divisor, 2):
            if n % d == 0:
                return False
        return True

    def check_primes(self):
        with self.pool as pool:
            self.results = [pool.apply(self.is_prime, (n,)) for n in self.numbers]

        [print(result) for result in self.results]


prime_numbers = PrimeNumbers(numbers)
prime_numbers.check_primes()
