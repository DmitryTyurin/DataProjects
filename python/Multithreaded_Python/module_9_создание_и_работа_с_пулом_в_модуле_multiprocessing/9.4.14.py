# Цель задачи: Создать асинхронную программу, которая обрабатывает информацию о пользователях, используя процессы для увеличения эффективности и скорости обработки. Вам предстоит реализовать функцию для асинхронной обработки данных о пользователях, где каждый пользователь представлен словарем с ключами "name", "age" и "city". Результаты обработки должны выводиться по мере их готовности с помощью колбек-функции.
#
# # Список словарей с информацией о пользователях
# # Полный список вшит в задачу
# users = [
#     {"name": "Алиса", "age": 30, "city": "Москва"},
#     {"name": "Борис", "age": 25, "city": "Санкт-Петербург"},
#     ...,
#     ...,
#     ...,
# ]
# Ключевые элементы задачи:
#
# Функция process_user_info(name, age, city) имитирует обработку данных, получая имя, возраст и город пользователя. Она "засыпает" на 1 секунду, имитируя длительную операцию, после чего возвращает сформированную строку с обработанной информацией.
#
# return f"{name}, {age} лет, из города {city}"
#
#
# Функция обратного вызова on_user_processed(result)будет вызываться асинхронно, когда обработка пользователя завершена. Она принимает результат работы функции обработки и печатает его.
#
# print(f"Обработанная информация о пользователе: {result}")
#
#
# Пул процессов Pool(4) Используется для создания пула процессов, который позволяет параллельно обрабатывать информацию о нескольких пользователях одновременно.
#
#
# Метод apply_async()отправляет задачу в пул процессов для асинхронной обработки. Принимает функцию process_user_info(), ключевые аргументы данных пользователя kwds=user, и функцию обратного вызова для обработки результата on_user_processed().
#
#
#
# Как код должен работать:
#
# Создается пул с количеством процессов =4.
# Для каждого пользователя из списка словарей users вызывается метод apply_async(). Методу передается функция обработки process_user_info(), данные пользователя в виде ключевых аргументов (kwds=user), и функция обратного вызова on_user_processed(), которая будет вызвана с результатом выполнения функции обработки.
# После отправки всех задач в пул процессов вызываются методы close() и join() , чтобы дождаться завершения всех операций и корректно завершить работу пула.

from multiprocessing import Pool, freeze_support
import time


users = [
    {"name": "Алиса", "age": 30, "city": "Москва"},
    {"name": "Борис", "age": 25, "city": "Санкт-Петербург"},
]


class ProcessingUser:
    def __init__(self, users: list):
        self.users = users
        self.results = []
        self.pool: Pool = Pool(4)

    @staticmethod
    def process_user_info(name: str, age: int, city: str) -> str:
        time.sleep(1)
        return f"{name}, {age} лет, из города {city}"

    @staticmethod
    def on_user_processed(result):
        print(f"Обработанная информация о пользователе: {result}")

    def main(self):
        self.results = [
            self.pool.apply_async(
                self.process_user_info, kwds=user, callback=self.on_user_processed
            )
            for user in users
        ]

        self.pool.close()
        self.pool.join()


if __name__ == "__main__":
    freeze_support()

    processing_user = ProcessingUser(users)
    processing_user.main()
