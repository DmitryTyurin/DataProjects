# Напишите функцию multu_recursive, которая принимает на вход вложенный список, конечными элементами которого являются целые числа  и строки, и возвращает произведение числовых элементов переданного списка.
# Уровень вложенности исходного списка произвольный.
# Произведение пустого списка должно быть равно 1. Также единице должно быть равно произведение списка, в котором нету ни одного числового значения.
# Ваша задача только написать определение рекурсивной функции multu_recursive


def multu_recursive(lst):
    if not lst:
        return 1
    elif isinstance(lst[0], list):
        return multu_recursive(lst[0]) * multu_recursive(lst[1:])
    elif isinstance(lst[0], (int, float)):
        return lst[0] * multu_recursive(lst[1:])
    else:
        return multu_recursive(lst[1:])


# Представьте, что у нас есть список целых чисел неограниченной вложенности. То есть наш список может состоять из списков, внутри которых также могут быть списки. Задача функции flatten вернуть новый линейный список, составленный из элементов входного списка, в котором уже отсутствует какая-либо вложенность. Элементы в плоском списке должны располагаться в том же порядке, как они следовали в исходном списке. Вот несколько примеров вызова функции flatten:
#
# flatten([1, [2, 3, [4]], 5]) => [1, 2, 3, 4, 5]
# flatten([1, [2, 3], [[2], 5], 6]) => [1, 2, 3, 2, 5, 6]
# flatten([[[[9]]], [1, 2], [[8]]]) => [9, 1, 2, 8]
# Ваша задача только написать определение функции flatten
#
# Разбор Youtube Patreon Boosty


def flatten(lst):
    if not lst:
        return []
    elif isinstance(lst[0], list):
        return flatten(lst[0]) + flatten(lst[1:])
    else:
        return [lst[0]] + flatten(lst[1:])
