# Напишите генератор-функцию gen_odd, которая принимает натуральное число n и генерирует последовательность нечетных чисел от 1 до n включительно
def gen_odd(n):
    for i in range(1, n + 1):
        if i % 2 != 0:
            yield i


# Ваша задача создать функцию-генератор my_range_gen, которая имеет один параметр n.
# Функция my_range_gen должна генерировать по порядку все числа от 0 до n не включительно. В общем, быть копией встроенной функции range, вызванной от одного аргумента.
# Ваша задача написать только определение функции-генератора my_range_gen
def my_range_gen(n):
    for i in range(n):
        yield i


# Ваша задача создать функцию-генератор gen_squares, которая принимает аргумент n и генерирует квадраты чисел от 1 до n включительно. Ниже несколько вариантов использования:
# Ваша задача написать только определение функции gen_squares
def gen_squares(n):
    for i in range(1, n + 1):
        yield i**2


# Ваша задача создать функцию-генератор gen_arithmetic_progression, которая при вызове принимает два значения:
# первый элемент прогрессии
# разность элементов прогрессии
# Функция-генератор gen_arithmetic_progression должна выдавать элементы бесконечной арифметической прогрессии с учетом переданных значений
# Ваша задача написать только определение функции-генератора gen_arithmetic_progression
def gen_arithmetic_progression(first_element, difference):
    while True:
        yield first_element
        first_element += difference


# Ваша задача создать функцию-генератор gen_fibonacci_numbers, которая принимает аргумент n и генерирует n-ое количество чисел Фибоначчи.
# Будем считать, что последовательность Фибоначчи такая: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
# Ваша задача написать только определение функции gen_fibonacci_numbers
def gen_fibonacci_numbers(n):
    a, b = 1, 1
    for i in range(n):
        yield a
        a, b = b, a + b


# Напишите генератор-функцию gen_factorial, которая принимает натуральное число n и генерирует факториалы чисел от 1! до n!
def gen_factorial(n):
    from math import factorial

    for i in range(1, n + 1):
        yield factorial(i)


# Измените генератор-функцию gen_factorial так, чтобы он стал выдавать бесконечную последовательность факториалов
def gen_factorial():
    from math import factorial

    i = 1
    while True:
        yield factorial(i)
        i += 1


# Напишите функцию-генератор my_enumerate, которая копирует работу встроенной функции enumerate.
def my_enumerate(iterable, start=0):
    n = start
    for item in iterable:
        yield n, item
        n += 1


# Если у вас есть итерируемый объект, который слишком велик для того, чтобы полностью поместиться в памяти (например, при работе с большими файлами), возможность дробить его на небольшие фрагменты и затем использовать их за раз может быть очень ценной.
# С этой задачей должна справиться функция-генератор chunker. Она должна принимать итерируемый объект и выдавать фрагмент указанного размера за раз.
# Ваша задача написать функцию-генератор chunker
def chunker(iterable, chunk_size):
    for i in range(0, len(iterable), chunk_size):
        yield iterable[i : i + chunk_size]
