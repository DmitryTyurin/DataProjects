# Напишите функцию print_results, которая принимает список кортежей. Каждый элемент вложенного кортежа состоит из названия предмета и оценки по нему.
# Функция print_results должна вывести информацию по экзаменам, отсортированную по возрастанию оценок. Название каждой пары предмета и оценки печатается на отдельной строке через пробел.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке
def print_results(marks: list):
    marks.sort(key=lambda x: x[1])

    for result in marks:
        print(result[0], result[1])


# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке
def print_results(marks: list) -> None:
    marks.sort(key=lambda x: x[1], reverse=True)

    for result in marks:
        print(result[0], result[1])


# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок, а в случае их равенства предметы должны выводиться в алфавитном порядке без учета регистра
def print_results(marks: list) -> None:
    marks.sort(key=lambda x: (-x[1], x[0].lower()))

    for result in marks:
        print(result[0], result[1])


# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок, а в случае их равенства предметы должны выводиться в обратном алфавитном порядке без учета регистра
def print_results(marks: list) -> None:
    # Сортировка по убыванию оценок, затем по возрастанию имени предмета в нижнем регистре
    marks.sort(key=lambda x: (x[1], x[0].lower()))

    # Вывод отсортированных результатов в обратном порядке
    for result in reversed(marks):
        print(result[0], result[1])


# Напишите функцию get_sort_lines, которая принимает список кортежей, в котором хранится информация о координатах двух точек на координатной прямой. Функция get_sort_lines должна вернуть новый список, в котором элементы расположены в порядке возрастания расстояния между точками, хранящимися в одном элементе.
# В случае равенства расстояний необходимо сортировать по возрастанию значения координаты первой точки, затем по возрастанию значения второй точки


def get_sort_lines(lines: list) -> list:
    def distance(line):
        x1, y1 = line
        return abs(y1 - x1)

    return sorted(lines, key=lambda line: (distance(line), line[0], line[1]))


# Напишите функцию print_goods, которая принимает список словарей. В самих словарях хранится информация о товарах: имя, модель и цвет. Задача функции print_goods вывести на экран информацию о товарах  в следующем формате
#
# Производитель: <make>, модель: <model>, цвет: <color>
# при этом товары должны быть отсортированы по цвету в лексикографическом порядке (по алфавиту) без учета регистра и по убыванию модели (второй критерий сортировки)


def print_goods(goods: list) -> None:
    goods.sort(key=lambda x: (x["color"].lower(), -x["model"]))

    for good in goods:
        print(
            f"Производитель: {good['make']}, модель: {good['model']}, цвет: {good['color']}"
        )


# Поставщик скидывает нашему заказчику информацию о товарах, а он хочет взглянуть на нее в отсортированном виде. Заказчик хочет видеть вывод, где вверху самые дорогие товары, внизу самые дешевые.
# Вот только поставщик предоставляет данные в виде списка строк, где каждая строка хранит информацию о товаре в виде
# Название_товара: цена_товара
# Название товара отделено от цены знаком двоеточия :.
# Ваша задача написать функцию print_goods , которая принимает список строк. Далее print_goods  должна выводить информацию о товарах, сортируя их сперва по цене, а затем по алфавиту без учета регистра. Вывод информации о каждом товаре делается в отдельной строке в следующем формате
# Цена_товара - Название_товара
# Цена должна выводиться с точностью до двух знаком после запятой


def print_goods(goods: list) -> None:
    goods.sort(key=lambda x: (-float(x.split(":")[1]), x.split(":")[0].lower()))

    for good in goods:
        print(f"{float(good.split(':')[1]):.2f} - {good.split(':')[0]}")


# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках).
# Ваша задача написать функцию print_best_and_worst_laureate, которая находит информацию, кто из номинантов получил наибольшее и наименьшее количество статуэток. Функция print_best_and_worst_laureate принимает на вход словарь, где указана номинация и имя победителя в ней (название фильма или имя актера). На основании этой информации функция print_best_and_worst_laureate должна в отдельных строках вывести лауреатов премии, набравших наибольшее и наименьшее количество статуэток и через запятую их количество.


def print_best_and_worst_laureate(winners: dict):
    counts = {}
    for award, winner in winners.items():
        if winner not in counts:
            counts[winner] = 0
        counts[winner] += 1

    # Находим лауреата с наибольшим количеством статуэток
    best_laureate = max(counts, key=counts.get)
    worst_laureate = min(counts, key=counts.get)

    print(
        f"{best_laureate}, {counts[best_laureate]}\n{worst_laureate}, {counts[worst_laureate]}"
    )


# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку. Информацию в отчете нужно расположить по убыванию средней оценки таксиста. Для этого вам нужно написать функцию print_order_rating, которая принимает на вход список кортежей. Каждый кортеж состоит из двух элементов: имя таксиста и оценка за поездку (целое число от 1 до 5).
# Функция print_order_rating должна расположить таксистов в порядке убывания их средней оценки и вывести имя каждого таксиста и его среднюю оценку в отдельной строке. В случае совпадения средних оценок нужно расположить каждую группу таксистов, имеющих одинаковый рейтинг,  по имени в алфавитном порядке без учета регистра

import itertools


def print_order_rating(ratings):
    driver_scores = {}

    for name, score in ratings:
        if name not in driver_scores:
            driver_scores[name] = [score]
        else:
            driver_scores[name].append(score)

    for key in driver_scores:
        driver_scores[key] = sum(driver_scores[key]) / len(driver_scores[key])

    sorted_drivers = sorted(driver_scores.items(), key=lambda x: (-x[1], x[0]))

    grouped_drivers = itertools.groupby(sorted_drivers, key=lambda x: x[1])

    for rating, drivers in grouped_drivers:
        for name, _ in sorted(drivers, key=lambda item: item[0].lower()):
            print(f"{name} {rating}")


# В социальных сетях все как обычно: одни люди выкладывают посты, другие их комментируют. Сервис по сбору аналитики решил найти у кого из владельцев постов самое большое количество уникальных комментаторов. Ваша задача помочь им в этом и собрать нужную информацию. Для это вам потребуется написать функцию print_statistic, которая принимает список кортежей. Каждый кортеж состоит из пары значений: автор поста и далее ник пользователя, оставившего комментарий к этому посту. Комментаторы могут повторяться и комментировать разных авторов.
# Функция print_statistic должна посчитать для каждого автора его уникальное количество комментаторов. Исходя из найденного количества  определяется популярность автора. Чем больше уникальных пользователей прокомментировало автора, тем он считается популярнее. Затем функция print_statistic должна для каждого автора вывести в порядке уменьшения популярности информацию в следующем виде
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать внимание в этой задаче.
# В случае одинаковой популярности у нескольких авторов, необходимо ранжировать по алфавитному порядку имени авторов без учета регистра

from collections import defaultdict


def print_statistic(comments):
    author_commentators = defaultdict(set)

    for author, commentator in comments:
        author_commentators[author].add(commentator)

    results = [
        (len(author_commentators[author]), author) for author in author_commentators
    ]
    results.sort(key=lambda x: (-x[0], x[1].lower()))

    for count, author in results:
        print(f"Количество уникальных комментаторов у {author} - {count}")
